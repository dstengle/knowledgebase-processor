{
  "docs/architecture/decisions/0001-python-as-implementation-language.md": "We will use Python as the primary implementation language for the Knowledge Base Processor.",
  "docs/architecture/decisions/0002-pydantic-for-data-models.md": "We will use Pydantic as the library for defining and validating data models in the Knowledge Base Processor.",
  "docs/architecture/decisions/0003-pydantic-model-versioning-strategy.md": "1.  We will use **`typing.Annotated`** in conjunction with a custom metadata class (e.g., `FieldMeta`) attached to Pydantic model fields as the primary method for documenting *field-level* schema evolution. This allows embedding information like the version a field was added or deprecated directly into the field's definition.\n2.  We will define a **custom base model** (e.g., `VersionedBaseModel`) inheriting from `pydantic.BaseModel`.\n    * This base model will include helper methods, such as `get_field_meta`, to provide a standardized way to access the `FieldMeta` information attached to fields.\n    * This base model will include a **`model_version` class variable**, typed using `typing.Literal`, intended to be **overridden by each inheriting model** to explicitly declare the version of that specific model schema.\n3.  All versioned data models in the system will inherit from this custom base model (`VersionedBaseModel`).\n\nThis decision establishes the *documentation* strategy for schema changes (both field-level and model-level) and a *consistent access pattern* for field metadata. It does *not* initially mandate the use of more complex backward compatibility features from \"Approach 3\" (like `alias`, `default_factory`, or complex validators). Those techniques remain options but will be considered and documented in separate ADRs if specific compatibility problems arise.",
  "docs/architecture/decisions/0004-package-structure.md": "We will adopt a relatively flat package structure that directly maps to the component architecture defined in our system documentation. Each major component will have its own top-level package, with cross-cutting concerns separated into dedicated packages.\n\nThe package structure will be organized as follows:\n\n```\nknowledgebase_processor/\n├── __init__.py\n├── models/\n│   ├── __init__.py\n│   ├── content.py\n│   ├── metadata.py\n│   └── common.py\n├── reader/\n│   ├── __init__.py\n│   └── reader.py\n├── processor/\n│   ├── __init__.py\n│   └── processor.py\n├── extractor/\n│   ├── __init__.py\n│   ├── base.py\n│   ├── frontmatter.py\n│   └── tags.py\n├── analyzer/\n│   ├── __init__.py\n│   ├── base.py\n│   ├── topics.py\n│   └── entities.py\n├── enricher/\n│   ├── __init__.py\n│   ├── base.py\n│   └── relationships.py\n├── metadata_store/\n│   ├── __init__.py\n│   └── store.py\n├── query_interface/\n│   ├── __init__.py\n│   └── query.py\n├── config/\n│   ├── __init__.py\n│   └── config.py\n├── utils/\n│   ├── __init__.py\n│   ├── logging.py\n│   └── text.py\n└── cli/\n    ├── __init__.py\n    └── main.py\n```\n\nThis structure can be visualized as:\n\n```mermaid\ngraph TD\n    Root[knowledgebase_processor/]\n    Root --> Models[models/]\n    Root --> Reader[reader/]\n    Root --> Processor[processor/]\n    Root --> Extractor[extractor/]\n    Root --> Analyzer[analyzer/]\n    Root --> Enricher[enricher/]\n    Root --> MetadataStore[metadata_store/]\n    Root --> QueryInterface[query_interface/]\n    Root --> Config[config/]\n    Root --> Utils[utils/]\n    Root --> CLI[cli/]\n    \n    Models --> ContentModels[content.py]\n    Models --> MetadataModels[metadata.py]\n    Models --> CommonModels[common.py]\n    \n    Reader --> ReaderImpl[reader.py]\n    \n    Processor --> ProcessorImpl[processor.py]\n    \n    Extractor --> ExtractorBase[base.py]\n    Extractor --> FrontmatterExtractor[frontmatter.py]\n    Extractor --> TagExtractor[tags.py]\n    \n    Analyzer --> AnalyzerBase[base.py]\n    Analyzer --> TopicAnalyzer[topics.py]\n    Analyzer --> EntityAnalyzer[entities.py]\n    \n    Enricher --> EnricherBase[base.py]\n    Enricher --> RelationshipEnricher[relationships.py]\n    \n    MetadataStore --> StoreImpl[store.py]\n    \n    QueryInterface --> QueryImpl[query.py]\n    \n    Config --> ConfigImpl[config.py]\n    \n    Utils --> LoggingUtils[logging.py]\n    Utils --> TextUtils[text.py]\n    \n    CLI --> CLIImpl[main.py]\n```",
  "docs/architecture/decisions/0005-poetry-as-package-manager.md": "We will use Poetry as the primary package and dependency manager for this Python project."
}